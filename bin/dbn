#!/usr/bin/env bash
set -euo pipefail
# 1) まず環境変数
DSN="${DB_URL:-}"

# 2) プロファイル指定（任意）
prof=""
while getopts "p:" opt; do
  case $opt in
    p) prof="$OPTARG" ;;
  esac
done
shift $((OPTIND-1))

# 3) 設定ファイル
cfg=""
[[ -f ".dbx.toml" ]] && cfg=".dbx.toml"

if [[ -z "$DSN" && -n "$cfg" ]]; then
  # defaultプロファイル名
  defp="$(yq -p=toml -oy '.default // "default"' "$cfg" 2>/dev/null || true)"
  [[ -z "$prof" ]] && prof="$defp"
  DSN="$(yq -p=toml -oy ".profiles.\"${prof}\".dsn // \"\"" "$cfg" 2>/dev/null || true)"
fi

[[ -z "$DSN" ]] && { echo "DSN が見つかりません（DB_URL か .dbn.toml/.dbx.toml を用意してね）"; exit 1; }

scheme="${DSN%%:*}"
if [[ "$scheme" =~ ^postgres ]]; then
  # --- Postgres ---
  list_sql="\
SELECT table_schema||'.'||table_name
FROM information_schema.tables
WHERE table_type='BASE TABLE' AND table_schema NOT IN ('pg_catalog','information_schema')
ORDER BY 1;"
  preview_sql='
-- columns
SELECT column_name AS col, data_type AS type, is_nullable AS nulls
FROM information_schema.columns
WHERE table_schema = '\''__SCH__'\'' AND table_name = '\''__TBL__'\''
ORDER BY ordinal_position;
-- outbound FKs
SELECT tc.table_name AS from_tbl, kcu.column_name AS from_col,
       ccu.table_name AS to_tbl, ccu.column_name AS to_col
FROM information_schema.table_constraints tc
JOIN information_schema.key_column_usage kcu
  ON tc.constraint_name = kcu.constraint_name AND tc.table_schema = '\''__SCH__'\'' AND tc.table_name = '\''__TBL__'\''
JOIN information_schema.constraint_column_usage ccu
  ON ccu.constraint_name = tc.constraint_name AND ccu.table_schema = '\''__SCH__'\'' AND ccu.table_name = '\''__TBL__'\'';
-- inbound FKs
SELECT tc.table_name AS to_tbl, kcu.column_name AS to_col,
       ccu.table_name AS from_tbl, ccu.column_name AS from_col
FROM information_schema.table_constraints tc
JOIN information_schema.key_column_usage kcu
  ON tc.constraint_name = kcu.constraint_name
JOIN information_schema.constraint_column_usage ccu
  ON ccu.constraint_name = tc.constraint_name
WHERE ccu.table_schema = '\''__SCH__'\'' AND ccu.table_name = '\''__TBL__'\''
ORDER BY 1,2;'
  tables="$(psql "$DSN" -X -At -F $'\t' -c "$list_sql")"
  export DBN_DSN="$DSN"
  printf "%s\n" "$tables" | fzf --prompt='table> ' --preview='
TABLE={}
SCH="${TABLE%%.*}"
TBL="${TABLE#*.}"
SQL=$(cat <<'"'"'EOS'"'"'
'"$preview_sql"'
EOS
)
SQL=${SQL//__SCH__/$SCH}
SQL=${SQL//__TBL__/$TBL}
PAGER=cat psql "$DBN_DSN" -X -q -P pager=off -P linestyle=unicode -P border=2 -c "$SQL"
' --bind 'enter:execute(echo "SELECT * FROM {} LIMIT 50;" | pbcopy)+abort'
elif [[ "$scheme" == "mysql" || "$scheme" == "mariadb" ]]; then
  # --- MySQL/MariaDB ---
  list_sql="SELECT TABLE_SCHEMA||'.'||TABLE_NAME
FROM INFORMATION_SCHEMA.TABLES
WHERE TABLE_TYPE='BASE TABLE' AND TABLE_SCHEMA NOT IN ('information_schema','mysql','performance_schema','sys')
ORDER BY 1;"
  # columns
  # outbound: KEY_COLUMN_USAGE + REFERENTIAL_CONSTRAINTS で辿る
  preview_sql="
-- columns
SELECT COLUMN_NAME AS col, COLUMN_TYPE AS type, IS_NULLABLE AS nulls
FROM INFORMATION_SCHEMA.COLUMNS
WHERE TABLE_SCHEMA = SUBSTRING_INDEX('\$TABLE','.',1) AND TABLE_NAME = SUBSTRING_INDEX('\$TABLE','.',-1)
ORDER BY ORDINAL_POSITION;
-- outbound FKs
SELECT kcu.TABLE_NAME AS from_tbl, kcu.COLUMN_NAME AS from_col,
       kcu.REFERENCED_TABLE_NAME AS to_tbl, kcu.REFERENCED_COLUMN_NAME AS to_col
FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu
WHERE kcu.TABLE_SCHEMA = SUBSTRING_INDEX('\$TABLE','.',1)
  AND kcu.TABLE_NAME   = SUBSTRING_INDEX('\$TABLE','.',-1)
  AND kcu.REFERENCED_TABLE_NAME IS NOT NULL
ORDER BY 1,2;
-- inbound FKs
SELECT kcu.TABLE_NAME AS to_tbl, kcu.COLUMN_NAME AS to_col,
       kcu2.TABLE_NAME AS from_tbl, kcu2.COLUMN_NAME AS from_col
FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu2
WHERE kcu2.REFERENCED_TABLE_SCHEMA = SUBSTRING_INDEX('\$TABLE','.',1)
  AND kcu2.REFERENCED_TABLE_NAME   = SUBSTRING_INDEX('\$TABLE','.',-1)
ORDER BY 1,2;"
  tables="$(mysql --batch --skip-column-names --raw "$DSN" -e "$list_sql")"
  printf "%s\n" "$tables" | fzf --prompt='table> ' --preview="
TABLE={}; mysql --table \"$DSN\" -e \"SET @TABLE='{}'; ${preview_sql}\"
" --bind 'enter:execute(echo "SELECT * FROM {} LIMIT 50;" | pbcopy)+abort'
else
  echo "対応していないスキームです: $scheme"; exit 1
fi

